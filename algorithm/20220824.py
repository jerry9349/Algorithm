### 그리디 알고리즘 ###
# 탐욕법, 현재 상황에서 지금 당장 좋은 것만 고르는 방법, 그리디 해법은 정당성 분석이 중요

# 루트 노드부터 시작하여 거쳐가는 노드 값의 합을 최대로 만들고 싶다. 최적의 해는? 매 순간마다 가장 큰 값을 선택해서 고르면 최대 값이 안 나올수도 있다.

# 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다
# 하지만 코딩 테스트에서 대부분의 그리디 문제는 '탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론'할 수 있어야 풀리도록 출제된다.


## 문제1
# 당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다. 손님에게 거슬러 주어야 할 돈이 n원일때 거슬러 주어야 할 동전의 최소 개수는? 단, 거슬러 줘야할 돈 n은 항상 10의 배수다.
# 최적의 해를 빠르게 구하는 방법은 가장 큰 화폐 단위부터 돈을 거슬러준다. n원을 거슬러 줄때는 가장 먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러 준뒤, 이후 100원, 50원, 10원을 차례대로 거슬러준다.
# 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문에 최적의 해를 보장.

# n = 1260 일때
# 500원 2개, 100원 2개, 50원 1개, 10원 1개

n = 1260
count = 0

# 큰 단위의 화폐부터 차례대로 확인하기
array = [500, 100, 50, 10]
for coin in array:
  count += n // coin # 1260원을 각 동전으로 나눈 몫
  # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
  n %= coin # 현재 금액에서 동전을 나눈 나머지

print("거슬러준 총 동전 갯수 :",count)
# 이 알고리즘의 시간 복잡도는 거슬러줘야 하는 금액과 무관하며, 동전의 총 종류(array 길이)에만 영향을 받음




## 문제2 : 1일 될 때까지
# 어떠한 수0 'n이 1일 될 때까지' 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려 함. 단, 두번째 연산은 n이 k로 나누어 떨어질 때만 선택할 수 있다.
# 1) n에서 1을 뺀다.
# 2) n을 k로 나눈다.
# 예를 들어 n이 17, k가 4라고 할때, 1번의 과정을 한 번 수행하면 n은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 n은 1이 된다. 결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 된다. 이는 n을 1로 만드는 최소 횟수다.
# n과 k가 주어질 때 n이 1이 될 때까지 1번 혹은 2번 '과정을 수행해야하는 최소 횟수'를 구하는 프로그램을 작성하라.

# 조건 : 첫째 줄에 N(1 <= N <= 100.000)과 (2 <= K <= 100.000)가 공백을 기준으로 하여 각각 자연수로 주어짐.
# 출력조건 : 첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 횟수의 최솟값을 출력

# 주어진 N에 대하여 '최대한 많이 나누기'를 수행
# N의 값을 줄일 때 '2 이상의 수로 나누는 작업이 1을 빼는 작업보다' 수를 훨씬 많이 줄일 수 있다.

# N, K을 공백을 기준으로 구분하여 입력 받기
n, k = map(int, input().split())
result = 0 # 총 연산을 수행하는 횟수

while True :
  # N이 K로 나누어 떨어지는 수가 될 때까지 빼기
  print("n :",n,", k :",k,", n//k : ", n//k,", (n//k) * K :",(n // k)*k)
  target = (n // k) * k
  print("target : ",target,", result :",result,", n:",n)
  result += (n - target)
  print(n-target)  
  n = target
  # N이 K보다 적을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
  if n < k :
    break
    
  # K로 나누기
  result += 1
  n //= k
  print("=========================")  
print("result :",result,", n :",n)
# 마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)
print("--------------------------") 
print("총 횟수 : ",result)

# 풀이
# 1. target = (n // k) * k : n이 k로 나누어 떨어지지 않아도, 가장 가까운 k로 나누어 떨어지는 수가 어떤 것인지 찾는다, target은 k로 나누어 떨어지는 수이며, target이 될때까지 -1 을 몇번 해야할지 알 수 있다
# 2. result += (n - target) : (n-target)을 하면 -1을 몇번 빼야할지 알 수 있음
# 3. n = target : 몇번 빼야할지 구하면 n이 tartget이 될 수 있도록 만든다
# 4. if n < k : break : N이 K보다 적을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
# 5. result += 1 : 아직 n > k 라면 더 나눠줘야 하므로 result에 횟수를 1씩 더해준다
# 6. n //= k : result ++ 해주고, n을 k로 나눠준 후 n 값을 나눈 값으로 계속 초기화 한다
# 7. result += (n - 1) : n이 1보다 크다면 1이 될수 있도록 만들기 위해 마지막으로 남은 수를 1씩 뺀다 


