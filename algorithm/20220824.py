### 그리디 알고리즘 ###
# 탐욕법, 현재 상황에서 지금 당장 좋은 것만 고르는 방법, 그리디 해법은 정당성 분석이 중요

# 루트 노드부터 시작하여 거쳐가는 노드 값의 합을 최대로 만들고 싶다. 최적의 해는? 매 순간마다 가장 큰 값을 선택해서 고르면 최대 값이 안 나올수도 있다.

# 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다
# 하지만 코딩 테스트에서 대부분의 그리디 문제는 '탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론'할 수 있어야 풀리도록 출제된다.


## 문제1
# 당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다. 손님에게 거슬러 주어야 할 돈이 n원일때 거슬러 주어야 할 동전의 최소 개수는? 단, 거슬러 줘야할 돈 n은 항상 10의 배수다.
# 최적의 해를 빠르게 구하는 방법은 가장 큰 화폐 단위부터 돈을 거슬러준다. n원을 거슬러 줄때는 가장 먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러 준뒤, 이후 100원, 50원, 10원을 차례대로 거슬러준다.
# 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문에 최적의 해를 보장.

# n = 1260 일때
# 500원 2개, 100원 2개, 50원 1개, 10원 1개

n = 1260
count = 0

# 큰 단위의 화폐부터 차례대로 확인하기
array = [500, 100, 50, 10]
for coin in array:
  count += n // coin # 1260원을 각 동전으로 나눈 몫
  # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
  n %= coin # 현재 금액에서 동전을 나눈 나머지

print("거슬러준 총 동전 갯수 :",count)
# 이 알고리즘의 시간 복잡도는 거슬러줘야 하는 금액과 무관하며, 동전의 총 종류(array 길이)에만 영향을 받음
