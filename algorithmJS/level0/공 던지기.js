
/*문제*/
/*
머쓱이는 친구들과 동그랗게 서서 공 던지기 게임을 하고 있습니다. 공은 1번부터 던지며 오른쪽으로 한 명을 건너뛰고 그다음 사람에게만 던질 수 있습니다. 친구들의 번호가 들어있는 정수 배열 numbers와 정수 K가 주어질 때, k번째로 공을 던지는 사람의 번호는 무엇인지 return 하도록 solution 함수를 완성해보세요.

제한사항
2 < numbers의 길이 < 100
0 < k < 1,000
numbers의 첫 번째와 마지막 번호는 실제로 바로 옆에 있습니다.
numbers는 1부터 시작하며 번호는 순서대로 올라갑니다.

입출력 예
numbers	k	result
[1, 2, 3, 4]	2	3
[1, 2, 3, 4, 5, 6]	5	3
[1, 2, 3]	3	2

입출력 예 설명
입출력 예 #1

1번은 첫 번째로 3번에게 공을 던집니다.
3번은 두 번째로 1번에게 공을 던집니다.
입출력 예 #2

1번은 첫 번째로 3번에게 공을 던집니다.
3번은 두 번째로 5번에게 공을 던집니다.
5번은 세 번째로 1번에게 공을 던집니다.
1번은 네 번째로 3번에게 공을 던집니다.
3번은 다섯 번째로 5번에게 공을 던집니다.
입출력 예 #3

1번은 첫 번째로 3번에게 공을 던집니다.
3번은 두 번째로 2번에게 공을 던집니다.
2번은 세 번째로 1번에게 공을 던집니다.
※ 공지 - 2023년 1월 25일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.

*/



/*
*
*
*
*
*
*/
/* 내 풀이1 */
function solution(numbers, k) {
  let arrayLength = (k * 2) + 1;
  let arr = [];
  for (let i = 0; arr.length < arrayLength; i++) {
    arr.push(numbers[i % numbers.length]);
  }
  return arr.filter((_, i) => i % 2 === 0)[k - 1];
}

/*
*
*
*
*
*
*/

/* 다른 사람 풀이 1*/
function solution(numbers, k) {

  return numbers[((2 * (k - 1))) % numbers.length];
}



/* 다른 사람 풀이 2*/
function solution(numbers, k) {
  return numbers[(--k * 2) % numbers.length];
}

/*
❗️ 2* (k-1)을 하는 이유는?

먼저, k - 1을 하는 이유는 문제에서 친구들의 번호가 1번부터 시작한다고 했을 때, 인덱스는 0부터 시작하기 때문입니다. 
예를 들어, 1번 친구는 인덱스 0, 2번 친구는 인덱스 1, 3번 친구는 인덱스 2와 같이 번호와 인덱스가 1씩 차이가 나기 때문에 k - 1을 해주어야 올바른 인덱스를 계산할 수 있습니다.


그리고 2 * (k - 1)을 하는 이유는 오른쪽으로 한 명을 건너뛰기 위해서입니다. 
문제에서는 오른쪽으로 한 명을 건너뛴 다음 사람에게만 공을 던진다고 했으므로, 현재 인덱스에서 2를 곱해주어 오른쪽으로 한 칸 이동한 인덱스를 구할 수 있습니다.


즉, k - 1을 해주면 현재 사람의 번호에 맞는 인덱스를 구할 수 있고, 그 인덱스에 2를 곱해주면 오른쪽으로 한 칸 이동한 인덱스를 구할 수 있습니다. 
그렇게 구한 인덱스에 해당하는 친구의 번호가 k번째로 공을 던지는 사람의 번호가 됩니다.

*/




